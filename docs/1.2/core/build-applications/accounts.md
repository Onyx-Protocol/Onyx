# Accounts

## Introduction

An account is an object in Chain Core that tracks ownership of assets on a blockchain by creating and tracking control programs.

A control program appears in each output of each transaction, defining a set of conditions that must be satisfied in order to spend the output - typically, that the spending transaction be signed by one or more specific keys.

When you create an account, you provide one or more “root” keys and a quorum. Each separate deposit to your account (i.e., each transaction output transferring assets to you) uses a new control program generated by your account. Each control program is unique, using newly derived child keys of the account’s root keys. For more information, see [Control Programs](control-programs.md#account-control-programs).

Your account balance is the sum of all assets in the set of unspent transaction outputs using any of your derived-key control programs. When you build an asset-transfer transaction, your account locates a sufficient quantity of unspent outputs that you control to be used as inputs to the new transaction.

The account object does not exist on the blockchain - it is local to Chain Core. Only the control programs created in the account are visible on the blockchain. However, when a new transactions is processed by Chain Core, it is annotated with local account data to enable powerful queries. For more information, see [Global vs. Local Data](../learn-more/global-vs-local-data.md).

## Overview

This guide will walk you through the basic functions of an account:

* [Create account](#create-account)
* [List accounts by tags](#list-accounts-by-tags)
* [Transfer asset units between local accounts](#transfer-asset-units-between-local-accounts) (within the same Chain Core)
* [Receive asset units from an external party](#receive-asset-units-from-an-external-party)
* [Transfer asset units to an external party](#transfer-asset-units-to-an-external-party)
* [List account transactions](#list-account-transactions)
* [List account balances](#list-account-balances)
* [Update tags on existing accounts](#update-tags-on-existing-accounts)

This guide assumes you know the basic functions presented in the [5-Minute Guide](../get-started/five-minute-guide.md).

### Sample Code

All code samples in this guide can be viewed in a single, runnable script. Available languages:

- [Java](../examples/java/Accounts.java)
- [Node](../examples/node/accounts.js)
- [Ruby](../examples/ruby/accounts.rb)

## Create account

* The `alias` is an optional, user-supplied, unique identifier that you can use to operate on the account. We will use this later to build transactions.
* The `quorum` is the threshold of keys that must sign a transaction to spend asset units controlled by the account.
* The `tag` is an optional key-value field used for arbitrary storage or queries. We will add several tags.

Create an account for Alice.

$code create-account-alice ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

Create an account for Bob.

$code create-account-bob ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

## List accounts by tags

To list all savings accounts, we build an accounts query, filtering on the `type` tag.

$code list-accounts-by-tag ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

## Transfer asset units between local accounts

To transfer assets between accounts within a Chain Core, we can build a transaction using an `account_id` or `account_alias`. This automatically creates a control program for the recipient account.

We will build a transaction transferring to units of gold from Alice’s account to Bob’s account.

$code build-transfer ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

Once we have built the transaction, we need to sign it with the key used to create Alice’s account. Note: We do not need to sign on behalf of Bob’s account, because Bob is not spending any assets - only receiving.

$code sign-transfer ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

Once we have signed the transaction, we can submit it for inclusion in the blockchain.

$code submit-transfer ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

## Receive asset units from an external party

When an external party wishes to transfer assets to your account, you must first create a **receiver** for the account. A receiver is a one-time-use payment object similar to an invoice. It contains a new control program derived from the account's root keys, as well as supplementary payment information such as an expiration date.

We will create a receiver for Bob’s account, which we can then serialize and send to an external party (see following example).

$code create-receiver ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

## Transfer asset units to an external party

If you wish to transfer asset units to an external party, you must first request a receiver from them. You can then build, sign, and submit a transaction sending asset units to their control program. We will use the receiver we created in Bob’s account to demonstrate this external facing functionality.

$code transfer-to-receiver ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

## List account transactions

Chain Core keeps a time-ordered list of all transactions in the blockchain. These transactions are locally annotated with account and asset data to enable intelligent queries. Note: local data is not present in the blockchain, see: [Global vs. Local Data](../learn-more/global-vs-local-data.md).

To list transactions involving Alice’s account, we build a transaction query, filtering on transactions where Alice spent or controlled any asset units.

$code list-account-txs ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

## List account balances

The balance of an asset in an account is the sum of all units in unspent outputs controlled by one of the account’s control programs. A helpful analogy is a pocketbook that contains one $10 bill and one $5 bill. The “balance” of the pocketbook is $15.

To list the balances of all assets in Alice’s account, we build a balance query, filtering on Alice’s account alias.

$code list-account-balances ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

To list all the unspent outputs that comprise the balance of gold in Alice’s account, we build an unspent outputs query, filtering on Alice’s account alias and the gold asset alias.

$code list-account-unspent-outputs ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

## Update tags on existing accounts

An account's tags can be updated after the account is created.

$code update-account-tags ../examples/java/Accounts.java ../examples/ruby/accounts.rb ../examples/node/accounts.js

After tags are updated, you can perform [queries for accounts](#list-account-transactions) based on the new values of the tags.

Account tag updates have a slightly different effect on transaction queries. Transactions are indexed by the accounts they comprise, and can be queried using the relevant accounts' tags. However, the transaction index is **not** updated retroactively based on account tag updates. Transactions that are indexed after the tag update will reflect the new value of the tags, but transactions indexed prior to the tag update will continue to reflect the old tag values. The same is true for unspent output and balance queries, which both use the transaction index.
