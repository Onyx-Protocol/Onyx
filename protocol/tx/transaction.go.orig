package tx

import (
	"chain/crypto/sha3pool"
	"chain/protocol/bc"
)

// The data needed for validation and state updates.
type TxHashes struct {
	ID        bc.Hash
	OutputIDs []bc.Hash // each OutputID is also the corresponding UnspentID
	Issuances []struct {
		ID           bc.Hash
		ExpirationMS uint64
	}
	VMContexts []VMContext // one per old-style Input
}

type VMContext struct {
	TxRefDataHash bc.Hash
	RefDataHash   bc.Hash
	TxSigHash     bc.Hash
	OutputID      *bc.Hash
	EntryID       bc.Hash
	AnchorID      *bc.Hash
}

// HashTx returns all hashes needed for validation and state updates.
func HashTx(oldTx *bc.TxData) (*TxHashes, error) {
	header, entries := mapTx(oldTx)
	hashes := new(TxHashes)

	// ID
	var err error
	hashes.ID, err = header.ID()
	if err != nil {
		return err
	}

	// OutputIDs
	for _, resultHash := range header.Content.(HeaderContent).Results {
		result := entries[resultHash]
		if result.Type == "output1" { // TODO: declare types as constants
			hashes.OutputIDs = append(hashes.OutputIDs, resultHash)
		}
	}

	var txRefDataHash bc.Hash // TODO: calculate this for the tx

	for entryID, entry := range entries {
		switch entry.Type {
		case "anchor1":
			// TODO: check time range is within network-defined limits
			iss := struct {
				ID           bc.Hash
				ExpirationMS uint64
			}{entryID, entry.Content.(AnchorContent).TimeRange.MaxTime}

			hashes.Issuances = append(hashes.Issuances, iss)
		case "issuance1":
			vmc := newVMContext(entryID, entry, txRefDataHash)
			c := entry.Content.(IssuanceContent)
			vmc.RefDataHash = c.Data
			vmc.AnchorID = &c.Anchor
		case "spend1":
			vmc := newVMContext(entryID, entry, txRefDataHash)
			c := entry.Content.(SpendContent)
			vmc.RefDataHash = c.Data
			vmc.OutputID = &c.SpentOutput

		}
	}

	return hashes
}
<<<<<<< HEAD
=======

func mapTx(tx *bc.TxData) (header *Entry, entries map[EntryRef]*Entry) {
	panic("TODO")
	// TODO: in addition to converting a bc.TxData to entries, also calculate the
	// hash of each entry so that it can be used as a key in the map
}

// populates the common fields of a VMContext for an Entry, regardless of whether
// that Entry is a Spend or an Issuance
func newVMContext(entryID EntryRef, entry *Entry, txRefDataHash bc.Hash) VMContext {
	vmc := new(VMContext)

	// TxRefDataHash
	vmc.TxRefDataHash = txRefDataHash

	// EntryID
	vmc.EntryID = entryID

	// TxSigHash
	hasher := sha3pool.Get256()
	defer sha3pool.Put256(hasher)
	hasher.Write(entryID)
	hasher.Write(hashes.ID)
	hasher.Read(vmc.TxSigHash[:])

	return vmc
}
>>>>>>> 98f9f004394008cca3e03796ade652c670250a36
